# [Segments Covering (1600)](https://codeforces.com/problemset/problem/2125/D)
## 题目大意：给几块积木，要求严丝合缝的拼出一段序列（即不重复不遗漏），且每块积木是有给定的概率能拼上去的。问最终能严丝合缝的拼出一段序列的概率是多少（对998244353取模）

## 思路：dp
   用dp[i]表示从1到i能够严丝合缝拼好（并且i之后没有积木存在）的概率，那么最终答案就是dp[m]，转移方程：对每个r为i的积木计算:dp[l-1]/(1-p)*p，把这些概率累加即得dp[i].
## 转移方程：
如果想要把[l,r]的积木插进去让[1,r]拼好，那么需要[1,l-1]拼好，所以我们把dp[1,l-1]取出来，它代表的就是[1,l-1]拼好并且l-1之后没有积木存在的概率。**重点**：此时我们本来假设的是l-1之后不存在积木，此时要让他存在，可以想象原来的概率式里是包含了一个（1-p)//p是当前[l,r]积木存在的概率，从不存在变为存在，那么就是原式除以(1-p)再乘p，最终就是转移方程。
## 黑科技：自动取模
如果涉及到逆元、取模等，把板子放上去后，直接Mint a,b，然后就可以畅用了，a/b都可以直接写的。
## 代码：
```cpp
		#include<bits/stdc++.h>
		using namespace std;
		#define int long long
		using ll = long long;
		#define pb push_back
		#define pii pair<int,int>

		const int MOD=998244353;

		const int MAXN=200005;

		
template<int MOD>
struct mint {
    int v;
    mint(long long _v = 0) { v = (-MOD < _v && _v < MOD) ? _v : _v % MOD; if (v < 0) v += MOD; }
    
    // 基础运算
    mint& operator += (const mint& o) { if ((v += o.v) >= MOD) v -= MOD; return *this; }
    mint& operator -= (const mint& o) { if ((v -= o.v) < 0) v += MOD; return *this; }
    mint& operator *= (const mint& o) { v = (long long)v * o.v % MOD; return *this; }
    
    // 逆元与除法 (费马小定理)
    mint pow(long long n) const {
        mint res = 1, a = *this;
        while (n > 0) { if (n & 1) res *= a; a *= a; n >>= 1; }
        return res;
    }
    mint inv() const { return pow(MOD - 2); }
    mint& operator /= (const mint& o) { return *this *= o.inv(); }

    // 各种运算符重载
    friend mint operator + (mint a, const mint& b) { return a += b; }
    friend mint operator - (mint a, const mint& b) { return a -= b; }
    friend mint operator * (mint a, const mint& b) { return a *= b; }
    friend mint operator / (mint a, const mint& b) { return a /= b; }
    
    // 输入输出
    friend ostream& operator << (ostream& os, const mint& a) { return os << a.v; }
    friend istream& operator >> (istream& is, mint& a) { long long x; is >> x; a = mint(x); return is; }
};

// 为这道题定义具体的模数
using Mint = mint<998244353>;
		
		
		struct Node
		{
			int l;
			Mint p;//概率
		};                                                                                                                       
		void solve()
		{
			int n,m;
			cin>>n>>m;
			vector<vector<Node>>v(m+1);
			vector<Mint>dp(m+1,0);
			Mint sum=1;
			for(int i=0;i<n;i++)
			{
				int l,r;
				Mint p,q;
				cin>>l>>r>>p>>q;
				v[r].pb({l,p/q});
				sum*=(1-p/q);
			}
			dp[0]=sum;
			for(int i=1;i<=m;i++)
			{
				for(auto& x:v[i])
				{
					dp[i]+=dp[x.l-1]/(1-x.p)*x.p;
				}
			}
			cout<<dp[m]<<"\n";
		}

		int32_t main() {
			cin.tie(0)->sync_with_stdio(0);
			int tc = 1;
			//cin >> tc; 
			while (tc--) solve();
			return 0;
			}
```
# [Lost Soul (1600)](https://codeforces.com/problemset/problem/2117/E)
## 看似困难，实则简单，相信自己，不要放弃
## 思维题，只要发现关键性质就简单了
